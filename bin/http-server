#!/usr/bin/env node

'use strict';

var colors     = require('colors/safe'),
    os         = require('os'),
    httpServer = require('../lib/http-server'),
    portfinder = require('portfinder'),
    opener     = require('opener'),
    parseArgs  = require('minimist');

var argv = parseArgs(process.argv.slice(2), {
  alias: {
    help: 'h',
    gzip: 'g',
    ext: 'e',
    silent: 's',
    utc: 'U',
    proxy: 'P',
    ssl: 'S',
    cert: 'C',
    key: 'K',
    robots: 'r'
  }
  unknown: function (arg) {
    return true; // if switch is unknown, add it to argv anyway
  },
  boolean: ['help', 'd', 'i', 'gzip', 'silent', 'utc', 'ssl', 'dotfiles'],
  string: ['proxy', 'cert', 'key'],
  default: {
    p: undefined, // no default to preserve portfinder behavior
    a: '0.0.0.0',
    d: true,
    i: true,
    gzip: false,
    ext: 'html', // due to ecstatic defaults, this is the same as false
    silent: false,
    cors: false, // can be bool or string
    o: null,
    c: 3600,
    utc: false,
    ssl: false,
    cert: 'cert.pem',
    key: 'key.pem',
    robots: true,
    dotfiles: true
  }
});

console.dir(argv);

var ifaces = os.networkInterfaces();

if (argv.help) {
  console.log([
    'usage: http-server [path] [options]',
    '',
    'options:',
    '  -p\t           Port to use [Default: 8080]',
    '  -a\t           Address to use [Default: 0.0.0.0]',
    '  -d\t           Show directory listings. Use --no-d to disable [Default: enabled]',
    '  -i\t           Display autoIndex. Use --no-i to disable [Default: enabled]',
    '  -g --gzip\t   Serve gzip files when possible [Default: disabled]',
    '  -e --ext\t   Default file extension if none supplied [Default: "html"]',
    '  -s --silent\t   Suppress log messages from output [Default: disabled]',
    '  --cors[=headers] Enable CORS via the "Access-Control-Allow-Origin" header [Default: disabled]',
    '                   Optionally provide CORS headers list separated by commas',
    '  -o [path]\t   Open browser window after starting the server [Default: disabled]',
    '  -c\t           Cache time (max-age) in seconds [Default: 3600], e.g. -c10 for 10 seconds.',
    '    \t           To disable caching, use -c-1.',
    '  -U --utc\t   Use UTC time format in log messages. [Default: disabled]',
    '',
    '  -P --proxy\t   Fallback proxy if the request cannot be resolved. e.g.: http://someurl.com',
    '',
    '  -S --ssl\t   Enable https [Default: disabled]',
    '  -C --cert\t   Path to ssl cert file [Default: cert.pem]',
    '  -K --key\t   Path to ssl key file [Default: key.pem]',
    '',
    '  -r --robots\t   Respond to /robots.txt [User-agent: *\\nDisallow: /]',
    '  --no-dotfiles\t   Do not show dotfiles',
    '  -h --help\t   Print this list and exit.'
  ].join('\n'));
  process.exit();
}

var port = argv.p || parseInt(process.env.PORT, 10),
    host = argv.a,
    ssl = argv.ssl,
    utc = argv.utc;
var logger;

if (!argv.silent) {
  logger = {
    info: console.log,
    request: function (req, res, error) {
      var date = utc ? new Date().toUTCString() : new Date();
      if (error) {
        logger.info(
          '[%s] "%s %s" Error (%s): "%s"',
          date, colors.red(req.method), colors.red(req.url),
          colors.red(error.status.toString()), colors.red(error.message)
        );
      }
      else {
        logger.info(
          '[%s] "%s %s" "%s"',
          date, colors.cyan(req.method), colors.cyan(req.url),
          req.headers['user-agent']
        );
      }
    }
  };
}
else if (colors) {
  logger = {
    info: function () {},
    request: function () {}
  };
}

if (!port) {
  portfinder.basePort = 8080;
  portfinder.getPort(function (err, port) {
    if (err) { throw err; }
    listen(port);
  });
}
else {
  listen(port);
}

function listen(port) {
  var options = {
    root: argv._[0],
    cache: argv.c,
    showDir: argv.d,
    autoIndex: argv.i,
    gzip: argv.gzip,
    robots: argv.robots,
    ext: argv.ext,
    logFn: logger.request,
    proxy: argv.proxy,
    showDotfiles: argv.dotfiles
  };

  if (argv.cors) {
    options.cors = true;
    if (typeof argv.cors === 'string') {
      options.corsHeaders = argv.cors;
    }
  }

  if (argv.ssl) {
    options.https = {
      cert: argv.cert,
      key: argv.key
    };
  }

  var server = httpServer.createServer(options);
  server.listen(port, host, function () {
    var canonicalHost = host === '0.0.0.0' ? '127.0.0.1' : host,
        protocol      = ssl ? 'https://' : 'http://';

    logger.info([colors.yellow('Starting up http-server, serving '),
      colors.cyan(server.root),
      ssl ? (colors.yellow(' through') + colors.cyan(' https')) : '',
      colors.yellow('\nAvailable on:')
    ].join(''));

    if (host !== '0.0.0.0') {
      logger.info(('  ' + protocol + canonicalHost + ':' + colors.green(port.toString())));
    }
    else {
      Object.keys(ifaces).forEach(function (dev) {
        ifaces[dev].forEach(function (details) {
          if (details.family === 'IPv4') {
            logger.info(('  ' + protocol + details.address + ':' + colors.green(port.toString())));
          }
        });
      });
    }

    if (typeof argv.proxy === 'string') {
      logger.info('Unhandled requests will be served from: ' + argv.proxy);
    }

    logger.info('Hit CTRL-C to stop the server');
    if (argv.o) {
      opener(
        protocol + canonicalHost + ':' + port,
        { command: argv.o !== true ? argv.o : null }
      );
    }
  });
}

if (process.platform === 'win32') {
  require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
  }).on('SIGINT', function () {
    process.emit('SIGINT');
  });
}

process.on('SIGINT', function () {
  logger.info(colors.red('http-server stopped.'));
  process.exit();
});

process.on('SIGTERM', function () {
  logger.info(colors.red('http-server stopped.'));
  process.exit();
});
